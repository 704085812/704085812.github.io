<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaEE基础, ClickSpace">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaEE基础 | ClickSpace</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ClickSpace" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ClickSpace</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ClickSpace</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaEE基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">
                                <span class="chip bg-color">知识集合</span>
                            </a>
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-07-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    45 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="就业班基础部分"><a href="#就业班基础部分" class="headerlink" title="就业班基础部分"></a>就业班基础部分</h2><h2 id="JavaEE基础部分"><a href="#JavaEE基础部分" class="headerlink" title="JavaEE基础部分"></a>JavaEE基础部分</h2><p>1、面向对象三大特征：封装、继承、多态</p>
<p>继承：extends      子类可以使用父类中非私有的成员</p>
<p>​       好处：①提高了代码的复用性（多个类相同的成员可以提取到一个类中）</p>
<p>​              ②提高了代码的维护性（如果方法的代码需要修改，修改一处即可）</p>
<p>​       弊端：类与类产生了关系，父类发生变化时子类实现也产生变化，耦合性增强，削弱了子类的独立性</p>
<p>2、继承中变量的成员访问特点：     在子类方法中访问一个变量，采用就近原则</p>
<p>​       ①子类局部范围   ②子类成员范围   ③父类成员范围</p>
<p>​       ④报错（不考虑父类的父类）</p>
<p>3、this/super 的作用</p>
<p>​    this代表本类成员对象的引用   super代表父类成员对象引用</p>
<p>​       子类中所有的构造方法默认都会访问父类中无参的构造方法</p>
<p>​       子类初始化前一定要先完成父类数据的初始化。原因在于，每一个子类构造方法的第一条语句默认都是：super( );</p>
<p>4、如果父类中没有无参构造方法，只有带参构造方法，该怎么办</p>
<p>​       ①通过使用super关键字去显示调用父类的带参构造方法</p>
<p>​       ②在子类中使用this去调用其他有参构造，调用本类的其他的构造方法，但是子类的其他的构造方法中一定会有一个去访问了父类的带参构造方法</p>
<p>③在父类中自己提供一个无参构造方法（推荐）</p>
<p>5、方法重写：     子类出现了和父类中一样的方法声明</p>
<p>​       方法名一样，参数列表也必须一样。</p>
<p>​       @Override注释用于检测当前方法是否是重写的方法</p>
<p>​       应用场景：子类需要父类功能但需要增加特有内容时</p>
<p>​       注意事项：①私有方法不能被重写（父类私有成员子类是不能继承的）</p>
<p>​                     ②子类方法访问权限不能更低（见6）</p>
<p>6、访问权限：权限修饰符</p>
<p>​              public       &gt;        protected       &gt;           默认      &gt;      private</p>
<p>不同包的无关类    不同包的子类     同一个包中的子类无关类    同一个类中 </p>
<p>7、继承的注意事项：</p>
<p>​       ①java中类只支持单继承，不支持多继承 （只有一个extends）</p>
<p>​              接口支持多继承</p>
<p>​       ②java中类支持多层继承</p>
<p>8、修饰符：</p>
<p>​       package：包，文件夹，用来管理文件，多级包用“.”隔开</p>
<p>​              package com.heima.com    带包编译/运行时后面继续点接类名（全路径）</p>
<p>​       import：导包，使用不同包下的类时需要导包，简化全路径</p>
<p>9、关键字：</p>
<p>​       final：代表最终版本    </p>
<p>​       修饰类：该类不能被继承（不能有子类但可以有父类）</p>
<p>​       修饰方法：该方法不能被重写</p>
<p>​       修饰变量：表明该变量是一个常量，不能再次被赋值</p>
<p>​              基本数据类型：表示数据值不能被改变</p>
<p>​              引用数据类型：引用类型的地址值不能被改变，但地址里的内容是可以改变的。</p>
<p>​       static：静态</p>
<p>​       修饰特点：①被类的所有对象共享，这是判断是否使用静态关键字的条件</p>
<p>​                                   只需对一个对象的静态变量赋值，其他的同类对象也发生改变</p>
<p>​                     ②可以通过类名调用，也可以通过对象名调用（推荐通过类名调用）</p>
<p>​       静态成员方法只能访问静态成员</p>
<p>10、多态：          同一对象，不同时刻表现出不同形态</p>
<p>​       前提：①要有继承或实现关系   ②要有方法的重写      ③要有父类引用指向子类对象</p>
<p>​       成员访问特点：成员变量：编译看父类，运行看父类（静态方法和变量一样）</p>
<p>​                            成员方法：编译看父类，运行看子类</p>
<p>​       多态好处：提高程序的扩展性；定义方法时，使用父类型为参数，在使用的时候，使用具体的子类型进行操作（不用写多个方法）</p>
<p>​       多态弊端：不能使用子类的特有成员</p>
<p>​       向上转型：父类引用指向子类对象                               Animal a = new Cat();</p>
<p>​       向下转型：子类型 对象名 =（子类型）父类引用        Cat c = (Cat)c; </p>
<p>11、抽象类：  abstract            共性的抽取</p>
<p>抽象方法不可实例化，抽象类中只定义（或部分实现）子类需要的方法。子类需要继承抽象类并自行实现</p>
<p>​       抽象类不一定有抽象方法，有抽象方法的类一定是抽象类 </p>
<p>​       抽象类的子类：要么重写抽象类中的所有抽象方法；要么是抽象类</p>
<p>​       抽象类可以继承具体类（concrete class）也可以继承抽象类</p>
<p>12、接口：   interface        对行为的抽象      public interface 接口名{ }           </p>
<p>​       实现接口： implements            public class 类名 implements 接口名</p>
<p>​       接口不能实例化                 通过子类对象实例化（多态）</p>
<p>​       接口的子类：要么重写接口中的所有抽象方法，要么子类也是抽象类</p>
<p>​       成员特点：①成员变量只能是常量   默认修饰符：public static final</p>
<p>​                     ②没有构造方法，因为接口主要是扩展功能的，而没有具体存在</p>
<p>​                     ③成员方法只能是抽象方法      默认修饰符：public abstract</p>
<p>​       接口与接口之间可以单继承也可以多继承</p>
<p>13、抽象类与接口设计理念：</p>
<p>​       抽象类：对类抽象，包括属性、行为</p>
<p>​       接口：对行为抽象，主要是行为</p>
<p>14、</p>
<p>类名作为方法的形参或返回值，其实调用的都是对象的【地址值】</p>
<p>抽象类作为形参或返回值，其实调用的都是该抽象类的【子类对象】</p>
<p>接口名作为形参或返回值，其实调用的是该接口的【实现类对象】</p>
<p>15、内部类：      一个类中定义一个类</p>
<p>​       访问特点：①内部类可以直接访问外部类的成员，包括私有</p>
<p>​                     ②外部类要访问内部类的成员，必须创建内部类的对象</p>
<p>​       成员内部类：和成员变量同等位置的内部类   （public/private class inner{ }）</p>
<p>​              Outer.Inner oi = new Outer().new Inner();</p>
<p>​              推荐使用方案：内部类的定义应该private私有化，再提供一个可以让外界调用的方法，在方法内部创建内部对象再调用</p>
<p>​       局部内部类：在方法中定义的类      （class inner{ } 外界无法使用）</p>
<p>​              外界无法直接使用，需要在方法内创建对象再使用</p>
<p>​              该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>​       匿名内部类： （new Inter( ){ 重写方法 }） 用来简化传统的代码</p>
<p>​              前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p>
<p>​              本质：是一个继承了该类或者实现了该接口的子类匿名对象</p>
<p>​              可以通过多态的形式直接接受： Inter I = new Inter（）{（重写方法）}</p>
<p>​              可以直接调用方法new Inter( ){重写method}.method( );</p>
<p>​              在开发中的使用：当发现某个方法需要接口或抽象类的子类对象，我们就可以直接传递一个匿名内部类过去，来简化传统的代码（不用再单独写一个类了）</p>
<p>16、常用API </p>
<p>Math类： 【abs 绝对值】  【ceil 天花板double】    【floor 地板double】   【round四舍五入后的int】</p>
<p>【max min    int】【 pow(a,b) a的b次幂double】【random() 返回[0.0,1.0)的正值 double】 </p>
<p>【Math.random()*2+1 1到3 的正值】</p>
<p>System类：  【exit(0) 终止java虚拟机     非零异常终止】           </p>
<p>【currentTimeMillis() 返回当前时间（毫秒）long】</p>
<p>Object类： 是目录结构的根 所有类都以Object为超类   </p>
<p>【toString() 按格式展示对象的属性值】  【 s1.equals(s2) 比较两对象，返回boolean】</p>
<p>Ctrl+B 查看方法源码</p>
<p>==比较的是数据地址值，equals比较的是对象的具体属性值</p>
<p>常常重写 toString 、equals 和 hashCode方法</p>
<p>工具类构造方法用private修饰，成员用public static修饰</p>
<p>Arrays类：  【toString(int[] a) 返回指定数组的内容的字符串表示形式】     【sort(int[] a) 按照数字顺序排列数组】 </p>
<p>17、冒泡排序： 排序的数据中相邻的数据进行两两比较，较大的数据放在后面，依次对所有的数据进行操作，直到所有数据排序完毕</p>
<p>冒泡排序如果有n个数据进行排序，总共需要比较n-1次 </p>
<p>每一次比较完毕，下一次的比较就会少一个数据参与</p>
<p>​       算法：双重循环，第一层arr.length-1控制轮次，第二层arr.length-1-i调整比较效率</p>
<p>18、包装类</p>
<p>​       int——Integer   char——Character</p>
<p>​       将基本类型封装为对象的好处在于：可以在对象中定义更多的功能方法操作该数据</p>
<p>常用操作： 用于基本数据类型与字符串之间的转换</p>
<p>​       Integer类：   【valueOf(int i) 返回指定int值得Integer实例】【valueOf(String s)返回保存String类型指定值的Integer对象】</p>
<p>int转为string：①直接在数字后面添加字符串    ②通过String类静态方法valueOf()</p>
<p>​       String转为int：①先将字符串数字转成Integer，再调用valueOf()方法</p>
<p>​                            ②通过Integer类的静态方法parseInt()进行转换</p>
<p>19、自动拆箱（包装——基本）和自动装箱（基本——包装）</p>
<p>​       Integer i = 100；  //自动装箱</p>
<p>​       i += 200；    //i + 200自动拆箱 i =i+200 自动装箱 </p>
<p>20、三个时间类</p>
<p>Date类        【无参构造Date()返回现在的时间】【有参构造Date(long date)返回从基准时间增加指定时间后的结果】      基准时间：CMT（格林尼治时间）1970.1.1，00：00=CST（美国、中国标准）1970.1.1，08：00</p>
<p>【getTime() 获取从基准时间到现在的毫秒值】 【setTime()设置时间，给毫秒值】</p>
<p>SimpleDateFormat类   用于以区域设置敏感的方式格式化和解析日期</p>
<p>【无参构造：使用默认格式打印时间】【有参构造：yyyy年MM月dd日HH：mm：ss自己设置的格式】 </p>
<p>【public final String format(Date date)将时间从Date格式化到String】  </p>
<p>【public Date parse(String source)将给定字符串解析为日期】</p>
<p>Calendar类 日历类            可以为某一时刻提供与日历字段转换的方法</p>
<p>​       日历字段：YEAR、MONTH(从0开始)、DAY_OF_MONTH、HOUR等信息（通过类名直接访问）</p>
<p>提供了类方法getInstance，返回一个Calendar对象，其日历字段已使用当前时间初始化</p>
<p>​              Calendar rightNow = Calendar.getInstance( );</p>
<p>​              类方法=static修饰，可通过类名调用。</p>
<p>非static修饰的是实例方法，必须创建一个实例才能调用</p>
<p>​       【public int get(int field) 根据输入的日历字段输出对应的值】</p>
<p>​       【public abstract void add(int field,int amount) 给指定的日历字段添加或减去给定的时间量】</p>
<p>​              【public final void set(int year,int month,int date) 设置当前日历的年月日】</p>
<p>21、异常体系： Throwable</p>
<p>​       Error: 严重问题，不需要处理</p>
<p>​       Exception： 异常类，程序本身可以处理的问题</p>
<p>​              运行时异常RuntimeException： 在编译期是不检查的，出现问题后需要回来修改代码（非必须显示）</p>
<p>​              编译时异常 非RuntimeException： 编译期就必须处理的，否则程序不能通过编译（必须显示处理）</p>
<p>​              运行时异常是RuntimeException子类，编译时异常是Exception子类，自定义异常类需要继承Exception</p>
<p>·         JVM默认处理方式：①把异常的名称、错误原因和异常位置等信息输出到控制台 ②停止运行</p>
<p>Throwable类： 【getMessage() 返回此throwable的详细消息字符串】   </p>
<p>【toString() 返回可抛出的简短描述】</p>
<p>​              【printStackTrace() 把异常的错误信息输出/打印在控制台】</p>
<p>​       ①try{</p>
<p>​                  可能出现异常的代码；</p>
<p>​              }catch(异常类名  变量名){</p>
<p>​                  异常的处理代码；</p>
<p>​              （程序执行try里的代码，出现问题执行catch里面的代码，结束后继续执行下面的代码）</p>
<p>}finally{</p>
<p>​       执行清除操作（close等）</p>
<p>​       或其他操作</p>
<p>​       （不管有没有异常， finally里的语句也一定会被执行，除非JVM退出）</p>
<p>​       （trycatch里有return时，finally的语句依然会执行，此时finally是在return的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值先暂存起来，无论finally做任何操作，返回的值都不会改变，依然返回暂存起来的值）</p>
<p>}</p>
<p>② public void 方法( ) throws 异常类名{  }           还有一种，在方法内throw异常对象</p>
<p>22、throws和throw的区别</p>
<p>throws用在方法声明后面，跟的是异常类名         throw用在方法声明体内，跟的是异常对象名</p>
<p>throws表示抛出异常，由该方法的调用者来处理  throw表示抛出异常，由方法体内的语句处理</p>
<p>throws表示出现异常的一种可能性，并不一定会发生这些异常  执行throw一定抛出了某种异常</p>
<p>23、集合体系</p>
<p>单列Collection</p>
<p>​       List可重复  有索引    存取有序</p>
<p>​              ArrayList  数组结构  查询快，增删慢</p>
<p>​              LinkedList  链表结构  查询慢，增删快</p>
<p>​       Set不可重复   无索引（只能通过迭代器和增强for遍历）</p>
<p>​              HashSet  哈希表（不保证存储和取出顺序一致）</p>
<p>​                     LinkedHashSet：具有可预测的迭代次序   链表保证次序一致  哈希表保证元素唯一</p>
<p>​              TreeSet  元素有序 可以自然排序或比较器排序</p>
<p>双列Map</p>
<p>​       HashMap、TreeMap（Key，Value）</p>
<p>24、迭代器Iterator     集合的专用遍历方式   （集合对象c） </p>
<p>​       迭代器通过集合的iterator()方法得到，所以说它依赖于集合存在</p>
<pre><code> Iterator&lt;String&gt; it = c.iterator();   返回对象的迭代器

​       while(it.hasNext( )){    //判断条件是还有下一个

​           String s = it.next();       //读取元素

​           System.out.println(s);

​       }</code></pre><p>​       remove() 从迭代器指向的集合中移除迭代器返回的最后一个元素</p>
<p>并发修改异常 ConcurrentModificationException   </p>
<p>​       迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致。</p>
<p>​       解决方法：用for循环进行遍历操作</p>
<p>25、List集合：</p>
<p>​       有序集合，用户可以控制每个元素的插入位置，用户可以通过整数索引访问元素，并搜索列表中的元素</p>
<p>​       特点：①有索引   ②可以存储重复元素   ③元素存取有序</p>
<p>List特有迭代器ListIterator  列表迭代器</p>
<p>​    允许延任一方向遍历，在迭代期间修改列表，并获取列表中迭代器的当前位置</p>
<pre><code>ListIterator&lt;String&gt; lit = list.listIterator()

while(lit.hasNext( )){

​       String s = lit.next();

​       if(s.equals(“world”)){

​       lit.add(“javaee”);    //可以add添加数据和set修改数据

}

}</code></pre><p>26、增强for循环                   （将元素单独取出来）    </p>
<pre><code>for(元素数据类型 变量名：数组/集合对象名){

​              循环体；

​       }

​       int[] arr = {1,2,3,4}

​       for(int i : arr){

​       sout(i);

}</code></pre><p>​       内部原理是一个Iterator迭代器，所以修改元素后会出现一样的异常</p>
<p>27、数据结构</p>
<p>​       栈：先进后出             队列：先进先出</p>
<p>​       数组结构：查询快、增删慢             队列结构：查询慢，增删快</p>
<p>28、ArrayList和LinkedList</p>
<p>​       ArrayList底层是数组结构，查询快，增删慢</p>
<p>​       LinkedList底层是链表结构，查询慢，增删快</p>
<p>29、泛型</p>
<p>​       List&lt;?&gt; 仅表示它是各种泛型List的父类，并不能把元素添加其中</p>
<p>List&lt;? extends Number&gt; Number或者其子类型</p>
<p>List&lt;? super Number&gt; Number或者其父类型</p>
<p>30、Set集合</p>
<p>​       特点：①元素存取无序      ②没有索引，只能通过迭代器或增强for遍历 ③不能存储重复元素</p>
<p>31、哈希值hashCode()     是JDK 通过对象的地址/字符串/数字计算出的int类型的数值</p>
<p>获取哈希值：public int hashCode( ) 返回对象的哈希值</p>
<p>特点：①同一对象多次调用hashCode( )返回的结果是相同的</p>
<p>​       ②默认情况下，不同对象的哈希值是不同的。</p>
<p>​       ③重写hashCode( )方法，可以实现让不同对象拥有相同哈希值。</p>
<p>32、HashSet集合</p>
<p>​       特点：①底层数据结构是哈希表      ②对集合的迭代顺序不作任何保证，不保证存储和取出顺序一致</p>
<p>​              ③没有带索引的方法，所以不能使用普通for循环遍历 ④由于是Set集合，所以不包含重复元素</p>
<p>HashSet保证元素唯一性原理：</p>
<p>①    根据哈希值计算存储位置，该位置没有元素则存入，有元素则进入②</p>
<p>②    当前元素和已存在元素对比哈希值，哈希值不同则存入当前元素，相同则进入③</p>
<p>③    equals()比较内容，内容不相同则存入当前元素，内容相同就不存储</p>
<p>LinkedHashSet集合</p>
<p>特点：①由哈希表和链表实现，具有可预测的迭代次序。 ②由链表保证元素有序，及存取顺序是一样的</p>
<p>④    由哈希表保证元素唯一</p>
<p>33、TreeSet集合</p>
<p>​       特点：①元素有序，按不同构造方法决定排序方式</p>
<p>​                     TreeSet( ):根据其元素的自然排序进行排序</p>
<p>​                     TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
<p>​              ②没有带索引的方法，不能使用普通for循环进行遍历       ③Set集合不包含重复元素</p>
<p>TreeSet自然排序： 让元素所属的类实现Comparable接口，重写compareTo( )方法</p>
<p>​              重写方法时，要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>TreeSet比较器排序：让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T 02)方法</p>
<p>​              重写方法时，要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<p>34、泛型             本质：参数化类型，即操作的数据类型被指定为一个参数</p>
<p>​       &lt;类型&gt;：指定一种类型            &lt;类型1，类型2，……&gt;：指定多种类型</p>
<p>​       将来具体调用的时候给定的类型可以看作实参，并且实参的类型只能是引用数据类型</p>
<p>​       好处：①把运行时期的问题提前到了编译时期             ②避免了强制类型转换</p>
<p>​       构成：泛型类、泛型方法、泛型接口</p>
<p>①泛型类： public class ClassName<type>{   }</type></p>
<p>​              ②泛型方法：public <type> void method(int i){   }</type></p>
<p>​              ③泛型接口：public interface InterfaceName<type> {   }</type></p>
<p>​       类型通配符：</p>
<p>​              ①&lt;?&gt;：表示元素类型未知，它的元素可以匹配任何类型</p>
<p>​                     注意：这种形式仅表示它是各种泛型的父类，并不能把元素添加到其中</p>
<p>​              ②&lt;? extends Number&gt;：表示Number或者其子类型</p>
<p>​              ③&lt;? super Number&gt;：表示Number或者其父类型</p>
<p>35、可变参数<br>        方法的形参为可变参数，那么该方法的参数个数是可变的</p>
<p>​       修饰符 返回值类型 方法名(数据类型… 变量名)</p>
<p>​       public static int sum(int… a){  }</p>
<p>​       注意：①这里的变量其实是一个数组      ②如果一个方法由多个参数，包括可变参数，可变参数要放在最后。</p>
<p>​       几个包含可变参数的集合类：</p>
<p>​              ①Arrays工具类public static List asList(T… a)：返回由指定数组支持的固定大小的列表</p>
<p>​                     返回的集合不能做增删操作，可以做修改操作</p>
<p>​              ②List接口public static List of(E… elements)：返回包含任意数量元素的不可变列表</p>
<p>​                     返回的集合不能做增删改操作</p>
<p>​              ③Set接口public static Set of(E… elements)：返回包含任意数量元素的不可变集合</p>
<p>​                     传入元素时不可以给重复的元素</p>
<p>​                     返回的集合不能做增删操作，没有修改的方法。</p>
<p>36、Map集合</p>
<p>​       interface Map&lt;K,V&gt;         K：键的类型，V：值的类型</p>
<p>​       特点：①键值对映射关系   ②一个键对应一个值   ③键不能重复，值可以重复      ④元素存取无序</p>
<p>​       方法：put(K key,V value)添加元素           containsKey()和contiansValue()判断是否包含</p>
<p>​       获取功能：get(Object key)根据键获取值        Set keyset() 获取所有键的集合</p>
<p>​                     Collection values()获取所有值的集合       Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()获取所有键值对对象集合</p>
<p>​       Map集合的遍历：①先获取所有键的集合，再通过键一个个取值</p>
<p>​                            ②获取所有键值对对象的集合，增强for遍历键值对对象集合，得到每一个键值对对象</p>
<pre><code>//获取所有键值对对象的集合

Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();

//遍历键值对对象的集合，得到每一个键值对对象

for (Map.Entry&lt;String, String&gt; me : entrySet) {

//根据键值对对象获取键和值

String key = me.getKey();

String value = me.getValue();

System.out.println(key + "," + value);

}</code></pre><p>​       在统计字符次数案例中：TreeMap用法和HashMap一样，但HashMap结果是无序的，TreeMap会对元素进行排序</p>
<p>37、Collections类：          是一个针对集合操作的工具类</p>
<p>​       public static void sort(List list)     将指定的列表按升序排序                             </p>
<p>​       public static void reverse(List&lt;?&gt; list)        反转指定列表中元素的顺序</p>
<p>​       public static void shuffle(List&lt;?&gt; list)         使用默认的随机源随机排列指定的列表</p>
<p>38、File类</p>
<p>​       File类是文件和目录路径名封装成对象的抽象表示，而无关是否存在</p>
<p>​       构造方法：</p>
<p>①File(String pathname)从一个路径名创建一个File对象      File f1 = new File(“E:\itcast\java.txt”);</p>
<p>​       ②File(String parent,String child):       File f2 = new File(“E:\itcast”,”java.txt”);</p>
<p>​       ③File(File parent,String child):          File f3 = new File(f ,”java.txt”)</p>
<p>​       功能方法：</p>
<p>​       ①public boolean creatNewFile( )       不存在该名称的文件时创造一个新的具有该抽象路径的空文件</p>
<p>​       ②public boolean mkdir( )           创建由此抽象路径名命名的目录</p>
<p>​       ③public boolean mkdirs( )         创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录</p>
<p>​       判断和获取功能：</p>
<p>​       ①public boolean isDirectory( )          测试此抽象路径名的File是否为目录</p>
<p>​       ②public boolean isFile( )                   测试此抽象路径名的File是否为文件</p>
<p>​       ③public boolean exists( )                  测试此抽象路径名的File是否存在</p>
<p>​       ④public String getAbsolutePath()     返回此抽象路径名的绝对路径名字符串</p>
<p>​       ⑤public String getPath( )                  将此抽象路径名转换为路径名字符串</p>
<p>​       ⑥public String getName( )                返回由此抽象路径名表示的文件或目录的名字</p>
<p>​       ⑦public String[ ] list( )                       返回此抽象路径名表示的目录中的文件和目录的名称的字符串数组</p>
<p>​       ⑧public File[ ] listFiles( )                    返回此抽象路径名表示的目录中的文件和目录的File对象数组</p>
<p>​       删除功能：public boolean delete( )   删除由此抽象路径名表示的文件或目录</p>
<p>​       绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件</p>
<p>​       相对路径：必须使用取自其他路径名的信息进行解释。  </p>
<p>​                     不加路径默认将文件添加在包路径下</p>
<p>​                     加相对路径就是从文件名开始逐级向上寻找同名目录</p>
<p>39、递归：          方法定义中调用方法本身的现象</p>
<p>​              将复杂问题转化为与原问题相似的小规模问题来解决</p>
<p>​       注意事项：①递归一定要有出口。否则内存溢出</p>
<p>​                     ②递归虽然有出口，但递归次数不能过多，否则内存溢出</p>
<p>​              public static int method(int n){</p>
<p>​       if(n==1 || n==2){</p>
<p>​       return 1;</p>
<p>}else{</p>
<p>​       return method(n-1) + method(n-2);</p>
<p>}</p>
<p>}</p>
<p>40、IO流：         输入/输出（Input/Output）             流：抽象概念，指数据传输</p>
<p>​       常见应用：文件复制；文件上传、文件下载</p>
<p>​       按数据流向：输入流：读数据；输出流：写数据          （以内存为基准，向硬盘输出还是由硬盘输入）</p>
<p>​       按数据类型：字节输入/输出流         字符输入/输出流</p>
<p>​              如果操作的是纯文本文件，优先使用字符流</p>
<p>​              如果操作的是图片、视频、音频等二进制文件或不知道文件类型，优先使用字节流</p>
<p>41、字节流写数据</p>
<p>​       字节流抽象基类：InputStream/OutputStream：所有字节输入/输出流的超类</p>
<p>​              子类名都以其父类名作为后缀。</p>
<p>​       字节输出流FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</p>
<p>​       步骤：①创建字节输出流对象（调用系统创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</p>
<p>​                     FileOutputStream fos = new FileOutputStream(“文件路径”);        完成了三件事</p>
<p>​              ②调用字节输出流对象的写数据方法</p>
<p>​                     fos.write(97);        将97写入文件</p>
<p>​              ③释放资源（关闭此文件输出流并释放与此流相关的任何系统资源）</p>
<p>​                     fos.close();            归还系统资源</p>
<p>​       写数据的方法：①void write(int b)：将指定的字节写入此文件输出流，一次写一个字节数据</p>
<p>​                     ②void write(byte[] b)：将b.leng长度的字节数组写入此文件输出流</p>
<p>​                     ③void write(byte[] b,int off,int len)：将指定的byte[]数组中从偏移量off开始的len个字节输入此文件</p>
<p>​       字节流写数据的常见问题</p>
<p>​              ①写数据如何进行换行：windows:\r\n    linux:\n   mac:\r</p>
<p>​              ②追加写入数据：构造方法创建对象public FileOutputStream(String name,boolean append)</p>
<p>创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头</p>
<p>42、字节流读数据</p>
<p>​       字节输入流：FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名</p>
<p>​       步骤：①创建字节输入流对象   ②调用字节输入流对象的读数据方法      ③释放资源</p>
<p>​       应用：字节流复制文本文件：          本质是把文本文件的内容读取出来再写入到另一文件</p>
<p>​              需要判断读取到的字节是否为-1，不是-1则存入文件，-1代表文件结尾。</p>
<p>43、字节缓冲流</p>
<p>​       BufferedOutputStream：应用程序可以向底层输出流写入字节，而不必为每个字节导致系统的调用。</p>
<p>​       BufferedInputStream：将创建一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区将够根据需要从所包含的输入流中重新填充，一次很多字节。</p>
<p>​       构造方法：BufferedOutputStream(OutputStream out)、       BufferedInputStream(InputStream in)</p>
<p>44、字符流：             字节流操作中文不方便</p>
<p>​       字符流 = 字节流 + 编码表</p>
<p>​       用字节流复制文本文件依然可以复制中文，操作系统都能识别成中文原因：汉字在存储时，无论选择哪种编码方式，第一个字节是负数。</p>
<p>​       字符集：是系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等，不同字符集有不同的字符编码：如ASCⅡ字符集、GBXXX字符集、Unicode字符集（UTF-8）</p>
<p>​       ASCⅡ基本字符集用7位表示一个字符，扩展字符集用8位表示一个字符</p>
<p>​       GBK：使用双字节编码方案</p>
<p>​       UTF-8：使用一至四个字节为每个字符编码，是电子邮件、网页等优先使用的编码</p>
<p>​              编码规则：①128个US-ASCⅡ字符，只需要一个字节编码</p>
<p>​                            ②拉丁文等字符需要两个字节编码</p>
<p>​                            ③大部分常用字（包括中文），使用三个字节编码</p>
<p>​                            ④其他极少使用的Unicode辅助字符，使用四字节编码</p>
<p>​       编解码方法：①byte[] getBytes()：使用平台的默认字符集将该String字符串编码为一系列字节</p>
<p>​                     ②byte[] getBytes(String charsetName)：使用指定的字符集将String进行编码</p>
<p>​                     ③String(byte[] bytes)：使用平台默认的字符集将一系列字节解码为一个String字符串</p>
<p>​                     ④String(byte[] bytes, String charsetName)：使用指定的字符集进行解码。</p>
<p>45、字符流和编码解码：</p>
<p>​       InputStreamReader：字节流→字符流：读取字节并使用指定/默认的字符集解码为字符</p>
<p>​       OutputStreamWriter：字符流→字节流：使用指定/默认的字符集将写入的字符编码为字节</p>
<p>​       flush( )：刷新流，之后还可以继续写数据</p>
<p>​       close( )：关闭流，释放资源，但是在关闭之前会执行flush。一旦关闭就不能再写数据。</p>
<p>46、字符缓冲流</p>
<p>​       BufferedWriter：将文本写入字符输出流，缓冲字符/数组/字符串，可指定缓冲区大小，默认值足够大</p>
<p>​       BufferedReader：从字符输入流中读取文本，缓冲字符</p>
<p>​       BufferedWriter(Writer out)：创建字符缓冲输出流对象</p>
<p>​       BufferedReader(Reader in)：创建字符缓冲输入流对象</p>
<p>​       字符缓冲流特有功能：</p>
<p>​              BufferedWriter： void newline( )写一行行分隔符，行分隔符字符串由系统属性定义</p>
<p>​                                   void write(String line)一次写一个字符串</p>
<p>​             BufferedReader： String readLine( )一次读一个字符串。结果包含行的内容的字符串，不包括任何终止字符。如果流的结尾已经到达，则为null。</p>
<p>47、IO流总结</p>
<p>​     <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133455646.png" alt="1594133455646">                                             </p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133447327.png" alt="1594133447327"></p>
<p>48、split( )方法用于分割字符串</p>
<p>​       例如：String[] strArray = line.split(“,”)，就是以逗号为分隔符分割字符串，得到一个数组</p>
<p>49、复制多级文件夹（流程）</p>
<p>​       创建数据源和目的地File对象</p>
<p>​       写复制文件夹的方法，先判断是否为目录，是则读取目录名称，在目的地创建同名目录，再遍历目录下所有文件，递归执行复制文件夹方法；否则调用复制文件方法</p>
<p>​       写复制文件方法，创建输入输出流对象，定义缓冲数组，复制文件。</p>
<p>​       最后抛出IO流异常，归还资源</p>
<p>49、标准输入输出流 ：            System类中的两个静态的成员变量：</p>
<p>​              ①public static final InputStream in：标准输入流。对应于键盘输入或由主机环境或用户指定的另一个输入源。      ②public static final PrintStream out：标准输出流。对应于显示输出或由主机环境或用户指定的另一个输出目标。</p>
<p>​              输出语句的本质是一个标准的输出流</p>
<p>​              PrintStream ps = System.out;            PrintStream类特有的方法，System.out都可以使用</p>
<p>​       字节打印流：PrintStream          字符打印流：PrintWriter</p>
<p>​              打印流特点：①只负责输出数据，不负责读取数据②永远不会抛出IOException③有独特的方法</p>
<p>​              PrintStream：①PrintStream(String fileName)：使用指定的文件名创建新的打印流</p>
<p>​                     ②使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出          ③可以改变输出语句的目的地：public static void setOut(PrintStream out)：重新分配标准输出流</p>
<p>​              PrintWriter：①PrintWriter(String fileName)：使用指定文件名创建，不需要执行自动刷新</p>
<p>​                     ②PrintWriter(Writer out,boolean autoFlush)：创建一个心的PrintWriter out，autoFlush如果为真则println，printf，或format方法将刷新输出缓冲区</p>
<p>对象序列化流：   将对象保存在磁盘中，或在网络中传输对象</p>
<p>​       原理：使用一个字节序列表示一个对象，该字节序列包括：对象的类型、对象的数据和对象中存储的属性等信息。字节序列写到文件后，相当于文件中持久保存了一个对象的信息；反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p>
<p>​       ObjectOutputStream：将Java对象的原始数据类型和图形写入。可以使用ObjectOutputSream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。</p>
<p>​       构造方法：ObjectOutputStream(OutputStream out)：创建一个写入指定OutputStream的序列化流</p>
<p>​       序列化方法：void writeObject(Object obj)：将指定的对象写入ObjectOutputStream。</p>
<p>​       注意：①一个对象想要被序列化，该对象所属的类必须实现Serializable接口</p>
<p>​              ②Serializable接口是一个标记接口，实现该接口不需要重写任何方法。</p>
<p>​       对象反序列化流：ObjectInputStream</p>
<p>​              ObjectInputStream反序列化之前先使用ObjectOutputStream编写的原始数据和对象</p>
<p>​              构造：ObjectInputStream(InputStream in):</p>
<p>​              反序列化方法：Object readObject( )：从ObjectInputStream读取一个对象</p>
<p>​       注意：①用对象序列化流序列化了一个对象之后，假如我们修改了对象所属的类文件，读取数据会出现问题：抛出InvalidClassException异常；</p>
<p>解决办法：重新序列化；</p>
<p>或给对象所属的类加serialVersionUID：public static final long serialVersionUID = 42L;</p>
<p>​              ②如果一个对象中的某个成员变量的值不想被序列化：给该成员变量加transient关键词修饰，该关键词标记的成员变量不参与序列化过程。</p>
<p>50、Properties集合</p>
<p>​       Properties是一个Map集合体系的集合类（K，V）</p>
<p>​       Properties可以保存到流中或从流中加载</p>
<p>​       属性列表中的每个键及其对应的值都是一个字符串。</p>
<p>​       特有方法（Map没有）：</p>
<p>​              ①Object setProperty(String key，String value)设置集合的键和值，均String类型，底层调用Hashtable方法put</p>
<p>​              ②String getProperty(String key)：使用此属性列表中指定的键搜索属性</p>
<p>​              ③Set stringPropertyNames( )：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串。</p>
<p>​       Properties和IO流结合：</p>
<p>​              ①void load(InputStream inStream)：从输入字节流读取属性列表（键和元素对）</p>
<p>​              ②void load(Reader reader)：从输入字符流读取属性列表（键和元素对）</p>
<p>​              ③void store(OutputStream out,String comments)：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</p>
<p>​              ④void store(Writer writer,String comments)：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(Reader)方法的格式写入输出字节流</p>
<p>51、多线程</p>
<p>​       进程：正在运行的程序；是系统进行资源分配和调用的独立单位，每一个进程都有它自己的内存空间和系统i资源</p>
<p>​       线程：是进程中的单个顺序控制流，是一条执行路径</p>
<p>​              一个进程仅有一条执行路径叫单线程，多条叫多线程</p>
<p>52、实现多线程方式一：【继承Thread类】</p>
<p>​              方法：void run() 在线程开启后，此方法将被调用执行</p>
<p>void start() 使此线程开始执行，Java虚拟机会调用run() 方法</p>
<p>​              定义一个MyThread类继承Thread类 → 在MyThread类中重写run() → 创建MyThread对象 → 创建线程</p>
<p>​              注意：①为什么要重写run()方法</p>
<p>​                     因为run()是用来封装被线程执行的代码</p>
<p>​                     ②run()和start()的区别？</p>
<p>​                     run()：封装线程执行的代码，直接调用，相当于普通方法的调用</p>
<p>​                     start()：启动线程；然后由JVM调用此线程的run()方法</p>
<p>​              方法：①void setName(String name)设置此线程的名称</p>
<p>​                     ②String getName()返回此线程的名称</p>
<p>​                     ③Thread currentThread()返回对当前正在执行的线程对象的引用</p>
<p>53、线程优先级：</p>
<p>​       调度方式：①分时调度模型：线程轮流使用CPU，平均分配时间片</p>
<p>②抢占式调度模型：优先让优先级高的线程使用CPU，优先级相同随机选取，并且会获得相对低级别线程更多的时间片</p>
<p>java是抢占式调度模型</p>
<p>​       多线程程序的执行是随机性的：一个CPU在某一时刻只能执行一条命令。不一定是哪个线程得到时间片</p>
<p>​              final int getPriority() 返回此线程的优先级</p>
<p>​              final void setPriority(int newPriority)：更改此线程的优先级，线程默认优先级是5；线程优先级的范围是1-10；</p>
<p>54、线程控制：</p>
<p>​       static void sleep(long millis):使当前正在执行的线程暂停指定的毫秒数</p>
<p>​       void join()等待这个线程死亡</p>
<p>​       void setDaemon(boolean on)当此线程标记为守护线程（并行变串行），当运行的线程都是守护线程时，无论守护线程是否结束，Java虚拟机将退出</p>
<p>55、线程的生命周期</p>
<p>​                                                  <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133424518.png" alt="1594133424518"></p>
<p>56、实现多线程方式二：实现Runnable接口</p>
<p>​       Thread实现了Runnable</p>
<p>​       构造方法Thread(Runnable target)分配一个新的Thread对象</p>
<p>​              Thread(Runnable target ,String name)分配一个新的Thread对象并命名</p>
<p>·      定义一个类MyRunnable实现Runnable接口 → 在MyRunnable类中重写run()方法 → 创建MyRunnable类的对象 → 创建Thread类的对象，把MyRunnable对象传入构造方法→启动线程</p>
<p>​       相比继承Thread类，实现Runnable接口的好处：</p>
<p>​              ①避免了Java单继承的局限性</p>
<p>​              ②适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p>
<p>57、线程同步</p>
<p>​       卖票案例</p>
<p>​       相同的票出现了两次，出现了负数的票：线程执行的随机性导致的</p>
<p>​       安全问题出现条件：①多线程环境   ②有共享数据      ③有多条语句操作共享数据</p>
<p>​       同步代码锁：</p>
<p>​              给多行代码加锁，让同一时间只有一个线程执行</p>
<p>​              synchronized(任意对象){</p>
<p>​                     多条语句操作共享数据的代码</p>
<p>}             任意对象可以看作一把锁</p>
<p>好处：解决了多线程的数据安全问题</p>
<p>弊端：当线程很多时，每个线程都去判断同步上的锁，耗费大量时间资源</p>
<p>​       同步方法的两种格式：</p>
<p>​       ①同步方法                        锁对象：this</p>
<p>​       修饰符 synchronized 返回值类型 方法名(方法参数){</p>
<p>​              方法体；</p>
<p>}</p>
<p>②静态同步方法                 锁对象：类名.class</p>
<p>修饰符 static synchronized 返回值类型 方法名(方法参数){</p>
<p>​       方法体；</p>
<p>}</p>
<p>线程同步的方法</p>
<p>​       StringBuffer：线程安全，可变的字符序列，JDK5被StringBuilder取代（有全部方法且不执行同步）</p>
<p>​       Vector：改进了List接口，与新的集合实现不同，Vector被同步，不需要线程安全时建议使用ArrayList</p>
<p>​       Hashtable：该类实现了哈希表，将键映射到值，任何非null对象都可以用作键或值，不需要线程安全时建议使用HashMap</p>
<p>58、Lock锁</p>
<p>​       Lock是接口不能直接使用，通过它的实现类ReentrantLock来实例化</p>
<p>synchronized缺陷：synchronized释放锁有两种情况，执行完代码块或线程发生异常。锁状态无法直观判断，如果A线程阻塞，B会一直等待。</p>
<p>Lock：锁对象可以直观判断，线程有多个锁获取的方式，线程可以尝试获得锁而不用持续等待。但Lock必须在finally中释放锁，否则会造成死锁。</p>
<p>​       void lock()获得锁         void unlock()释放锁</p>
<p>​       在执行方法体前lock，在执行后unlock</p>
<pre><code>while(true){

​       try{

​       lock.lock();

​       if(tickets &gt; 0){

​       try{

​       Thread.sleep(100);

}catch(InterruptedException e){

​       e.printStackTrace();

}

System.out.println(Thread.currentThread().getName() + “正在出售第几张票”)；

tickets --;

}

}finally{

​       lock.unlock();

}

}</code></pre><p>59、生产者消费者模式</p>
<p>​       是一种经典的多线程协作的模式。包含两类线程：生产者线程生产数据、消费者线程消费数据。</p>
<p>​       为了解耦生产者消费者关系，采用共享的数据区域，生产者生产数据后放置在共享数据区中，不需要关系消费者的行为；消费者只需从共享数据区中获取数据，不需要关心生产者</p>
<p>​       Object类的方法（不需要对象调用）：</p>
<p>​              void wait()：导致当前线程等待，直到另一线程调用该对象的notify或notifyAll</p>
<p>​              void notify()：唤醒正在等待对象监视器的单个线程</p>
<p>​              void notifyAll()：唤醒正在的等待对象监视器的所有线程</p>
<p>​       </p>
<p>60、网络编程</p>
<p>​       三要素：ip地址、端口、协议</p>
<p>​       ip地址：计算机在网络中的唯一标识；IPv4（32bit）IPv6（128bit）127.0.0.1回送地址</p>
<p>​              InetAddress类：表示IP地址</p>
<p>​              static InetAddress getByName(String host)：通过主机名称或IP地址获取对象</p>
<p>​              String getHostName()：获取此IP地址的主机名称</p>
<p>​              String getHostAddress()：返回此文本显示中的IP地址字符串</p>
<p>​       端口：设备上应用程序的唯一标识。0<del>65535，其中0</del>1023用于一些知名的网络服务或应用</p>
<p>​       协议：连接和通信的规则</p>
<p>61、UDP：                 用户数据报协议</p>
<p>​       UDP是一种无连接通信协议：在数据传输时，数据的发送端和接收端不建立逻辑连接，不确认对方是否存在</p>
<p>​       消耗资源少，通信效率高</p>
<p>​       通信两端各建立一个Socket对象，但两个Socket只是发送、接收数据的对象</p>
<p>​       DatagramSocket类作为基于UDP的Socket类</p>
<p>​              DatagramSocket()：创建数据报套接字并将其绑定到本机地址上的任何可用接口</p>
<p>​              DatagramPacket(byte[] buf, int len, InetAddress add, int port)：创建数据包，发送长度为len的数据包到指定主机的指定接口</p>
<p>​              void send(DatagramPacket p)：发送数据包</p>
<p>​              void close()：关闭数据包套接字</p>
<p>​              void receive(DatagramPacket p)：从此套接字接受数据包</p>
<p>​       DatagramPacket类：         (继承自Object类，用来打包数据)</p>
<p>​              DatagramPacket(byte[] buf, int len)：创建一个DatagramPacket用于接收数据长度为len的数据包</p>
<p>​              byte[] getData()：返回数据缓冲区</p>
<p>​              int getLength()：返回要发送的数据的长度或接收数据的长度</p>
<p>​       发送数据步骤：①创建发送端的Socket对象(DatagramSocket) ②创建数据，并把数据打包 ③调用DatagramSocket对象的方法发送数据  ④关闭发送端</p>
<p>​       接收数据步骤：①创建接收端的Socket对象(DatagramSocket) ②创建一个数据包，用于接收数据 ③调用DatagramSocket对象的方法接收数据 ④解析数据包，并把数据在控制台显示 ⑤关闭接收端</p>
<p>62、TCP：                  传输控制协议</p>
<p>​       TCP是面向连接的协议：经历三次握手明确建立连接再开始传输数据</p>
<p>​       TCP使用Socket对象代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</p>
<p>​       Java为客户端提供了Socket类，为服务端提供了ServerSocket类</p>
<p>​       Socket类的构造以及方法：</p>
<p>​              Socket(InetAddress address, int port)：创建流套接字并将其连接到指定IP指定端口号</p>
<p>​              Socket(String host, int port)：创建流套接字并将其连接到指定主机上的指定端口号</p>
<p>​              InputStream getInputStream()：返回此套接字的输入流</p>
<p>​              OutputStream getOutputStream()：返回此套接字的输出流</p>
<p>​              创建客户端的Socket对象 → 获取输出流，写数据 → 释放资源</p>
<p>​       ServerSocket类的构造以及方法</p>
<p>​              ServletSocket(int port)：创建绑定到指定端口的服务器套接字</p>
<p>​              Socket accept()：监听要连接到此的套接字并接收它</p>
<p>​              创建服务器端的Socket对象 → 监听客户端的套接字 → 获取输入流，读数据 → 释放资源</p>
<p>​       TCP和UDP套接字与输入输出流以及File类结合起来就可以传输文件了</p>
<p>63、Lambda表达式</p>
<p>​       前提：①是一个接口 ②接口中有且仅有一个抽象方法</p>
<p>​       匿名内部类编译后会产生一个单独的.class字节码文件，Lambda编译后不会产生.class文件，而是在运行时动态生成。</p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133377545.png" alt="1594133377545"></p>
<p>​       箭头是固定写法，括号里是传入的参数类型，必须根据上下文环境才能推导Lambda的含义</p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133372103.png" alt="1594133372103"></p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133368195.png" alt="1594133368195"></p>
<p>64、接口中的几种方法</p>
<p>​       ①常量public static final</p>
<p>​       ②抽象方法 public abstract </p>
<p>③接口中的默认方法public default void method(){ }                                  出现于java8</p>
<p>​       默认方法不是抽象方法，不强制重写，重写的时候去掉default关键字</p>
<p>​       ④接口中的静态static方法只能通过接口名调用，不能通过实现类名或者对象名调用。              出现于Java8</p>
<p>​       ⑤私有private方法：为了解决默认/静态方法的问题                                出现于Java9</p>
<p>​              解决问题：当抽象方法和静态方法中包含一段相同代码时，常考虑抽取为共性方法，而当共性方法不需要被使用时，可以使用私有化将其隐藏</p>
<p>​              注意：①默认方法可以调用私有的静态方法和默认方法 ②静态方法只能调用私有的静态方法</p>
<p>65、方法引用：          是Lambda的孪生兄弟</p>
<p>​       用来调用上下文已存在的代码块</p>
<p>​       使用“::”来省略可通过上下文推导的部分</p>
<p>​       类名：：静态方法</p>
<p>​       Lambda：method(s -&gt; Integer.parseInt(s))      引用：method(Integer :: parseInt)</p>
<p>​       Lambda被类方法替代时，它的形式参数全部传递给静态方法做参数。</p>
<p>​       对象：：成员方法</p>
<p>​       类名：：成员方法</p>
<p>​       类名：：new                引用构造器</p>
<p>66、函数式接口：                    有且仅有一个抽象方法的接口</p>
<p>​       通过@FunctionalInterface来检测是否为函数式接口</p>
<p>​       常用函数式接口：</p>
<p>​              ①Supplier接口：生产线接口    如果指定了接口的泛型是什么类型，那么接口中的get方法就会产生这种类型。           T get( )：按照某种实现逻辑(由Lambda表达式实现)返回一个数据</p>
<p>​              ②Consumer接口：消费型接口  它消费的数据的数据类型由泛型指定</p>
<p>​                     void accept(T t)：对给定的参数执行此操作</p>
<p>​                     default Consumer andThen(Consumer)：返回一个组合的Consumer，依次执行此操作，然后执行after操作</p>
<p>​              ③Predicate接口：通常用于判断参数是否满足指定的条件</p>
<p>​              ④Function&lt;T,R&gt;接口：通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值</p>
<p>59、Stream流</p>
<p>​       使用filter过滤集合的字符串信息</p>
<p>​       生成Stream流的方式：</p>
<p>​              ①Collection：使用默认方法stream()生成流 default Stream stream();</p>
<p>​              ②Map：把Map转成Set集合，间接生成流</p>
<p>​              ③数组，通过Stream接口的静态方法of(T… values)生成流</p>
<p>​       中间操作方法：                 执行完此操作后，Stream流依然可以继续执行其他操作</p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133303278.png" alt="1594133303278"></p>
<p>​       终结操作方法：                 执行完此方法后，Stream流将不能执行其他操作</p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133309456.png" alt="1594133309456"></p>
<p>​       收集操作方法：                 对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中</p>
<p>   <img src="/2020/07/07/javaee-ji-chu/C:%5CUsers%5CClick%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594133317301.png" alt="1594133317301"></p>
<p>60、类加载器</p>
<p>​       JVM进行操作的三步：当程序要使用某个还未被加载到内存的类时，JVM会进行类的加载、类的连接、类的初始化三个步骤</p>
<p>​       类的加载：将.class文件读入内存，并位置创建一个java.lang.Class对象。任何类被使用时系统都会为之创建一个java.lang.Class对象</p>
<p>​       类的连接：分三个阶段：①验证阶段：检验被加载的类是否有正确的内部结构，并和其他类协调一致</p>
<p>​                                          ②准备阶段：为类的类变量分配内存，并设置默认初始化值</p>
<p>​                                          ③解析阶段：将类的二进制数据中的符号引用替换为直接引用</p>
<p>​       类的初始化：对类变量进行初始化步骤</p>
<p>​              ①假如类还未被加载和连接，先进行加载和连接</p>
<p>​              ②假如类的直接父类未被初始化，先初始化父类</p>
<p>​              ③假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>​              注意：父类被初始化时仍需执行①-③步骤</p>
<p>​              类的初始化时机：①创建类的实例   </p>
<p>②调用类的类方法      </p>
<p>③访问类或者接口的类变量，或者为该类变量赋值      </p>
<p>④使用反射方式来创建某个类或接口对应的java.lang.Class对象       </p>
<p>⑤初始化某个类的子类      </p>
<p>⑥直接使用java.exe命令来运行某个子类</p>
<p>​       类加载器：负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。</p>
<p>​       JVM的类加载机制：</p>
<p>①全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入，除非显示使用另一个类加载器来载入</p>
<p>②父类委托：当一个类加载器试图加载某个Class时，先让父加载器试图加载此Class，只有在父类无法加载该类时才尝试从自己的类路径中加载该类</p>
<p>③缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区。</p>
<p>61、反射</p>
<p>​       指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建变量，调用方法的一种机制，由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期依然可以拓展。</p>
<p>​       获取Class类对象的三种方式：①类名.class属性 ②对象名.getClass()方法 ③Class.forName(全类名)方法</p>
<p>​       </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Click</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.clicklyj.com/2020/07/07/javaee-ji-chu/">https://www.clicklyj.com/2020/07/07/javaee-ji-chu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Click</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">
                                    <span class="chip bg-color">知识集合</span>
                                </a>
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/07/mysql-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="MySQL基础">
                        
                        <span class="card-title">MySQL基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这是MySQL基础知识学习过程中记录的小知识点，建议大部分内容一扫而过，供复习用。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                    <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">
                        <span class="chip bg-color">知识集合</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/07/javase-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="javaSE基础">
                        
                        <span class="card-title">javaSE基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这是java基础知识学习过程中记录的小知识点，建议大部分内容一扫而过，供复习用。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/">
                        <span class="chip bg-color">知识集合</span>
                    </a>
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: ClickSpace<br />'
            + '文章作者: Click<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="/about" target="_blank">Click</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">23k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/704085812" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:704085812@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=704085812" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 704085812" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
